{"file_contents":{"README.md":{"content":"# Anonymous Message Board\n\nThis is the boilerplate for the Anonymous Message Board project. Instructions for completing your project can be found at https://www.freecodecamp.org/learn/information-security/information-security-projects/anonymous-message-board\n","size_bytes":259},"assertion-analyser.js":{"content":"/*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*       DO NOT EDIT THIS FILE\n*       For FCC testing purposes!\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*/\n\nfunction objParser(str, init) {\n  // finds objects, arrays, strings, and function arguments\n  // between parens, because they may contain ','\n  var openSym = ['[', '{', '\"', \"'\", '('];\n  var closeSym = [']', '}', '\"', \"'\", ')'];\n  var type;\n  for(var i = (init || 0); i < str.length; i++ ) {\n    type = openSym.indexOf(str[i]);\n    if( type !== -1)  break;\n  }\n  if (type === -1) return null;\n  var open = openSym[type];\n  var close = closeSym[type];\n  var count = 1;\n  for(var k = i+1; k < str.length; k++) {\n    if(open === '\"' || open === \"'\") {\n      if(str[k] === close) count--;\n      if(str[k] === '\\\\') k++;\n    } else {\n      if(str[k] === open) count++;\n      if(str[k] === close) count--;\n    }\n    if(count === 0) break;\n  }\n  if(count !== 0) return null;\n  var obj = str.slice(i, k+1);\n  return {\n    start : i,\n    end: k,\n    obj: obj\n  };\n}\n\nfunction replacer(str) {\n  // replace objects with a symbol ( __#n)\n  var obj;\n  var cnt = 0;\n  var data = [];\n  while(obj = objParser(str)) {\n    data[cnt] = obj.obj;\n    str = str.substring(0, obj.start) + '__#' + cnt++ + str.substring(obj.end+1)\n  }\n  return {\n    str : str,\n    dictionary : data\n  }\n}\n\nfunction splitter(str) {\n  // split on commas, then restore the objects\n  var strObj = replacer(str);\n  var args = strObj.str.split(',');\n  args = args.map(function(a){\n    var m = a.match(/__#(\\d+)/);\n    while (m) {\n      a = a.replace(/__#(\\d+)/, strObj.dictionary[m[1]]);\n      m = a.match(/__#(\\d+)/);\n    }\n    return a.trim();\n  })\n  return args;\n}\n\nfunction assertionAnalyser(body) {\n  \n  // already filtered in the test runner\n  // // remove comments\n  // body = body.replace(/\\/\\/.*\\n|\\/\\*.*\\*\\//g, '');\n  // // get test function body\n  // body = body.match(/\\{\\s*([\\s\\S]*)\\}\\s*$/)[1];\n  \n  if(!body) return \"invalid assertion\";\n  // replace assertions bodies, so that they cannot\n  // contain the word 'assertion'\n\n  var body = body.match(/(?:browser\\s*\\.\\s*)?assert\\s*\\.\\s*\\w*\\([\\s\\S]*\\)/)[0];\n  var s = replacer(body);\n  // split on 'assertion'\n  var splittedAssertions = s.str.split('assert');\n  var assertions = splittedAssertions.slice(1);\n  // match the METHODS\n\n  var assertionBodies = [];\n  var methods = assertions.map(function(a, i){\n    var m = a.match(/^\\s*\\.\\s*(\\w+)__#(\\d+)/);\n    assertionBodies.push(parseInt(m[2]));\n    var pre = splittedAssertions[i].match(/browser\\s*\\.\\s*/) ? 'browser.' : '';\n    return pre + m[1];\n  });\n  if(methods.some(function(m){ return !m })) return \"invalid assertion\";\n  // remove parens from the assertions bodies\n  var bodies = assertionBodies.map(function(b){\n    return s.dictionary[b].slice(1,-1).trim();\n  });\n  assertions = methods.map(function(m, i) {\n    return {\n      method: m,\n      args: splitter(bodies[i]) //replace objects, split on ',' ,then restore objects\n    }\n  })\n  return assertions;\n}\n\nmodule.exports = assertionAnalyser;\n","size_bytes":2985},"server.js":{"content":"'use strict';\nrequire('dotenv').config();\nconst express     = require('express');\nconst bodyParser  = require('body-parser');\nconst cors        = require('cors');\nconst helmet      = require('helmet');\nconst { MongoClient } = require('mongodb');\n\nconst apiRoutes         = require('./routes/api.js');\nconst fccTestingRoutes  = require('./routes/fcctesting.js');\nconst runner            = require('./test-runner');\n\nconst app = express();\n\n// Configuraciones de seguridad con helmet\napp.use(helmet({\n  // Solo permitir que el sitio se cargue en un iFrame en sus propias páginas\n  frameguard: { action: 'sameorigin' },\n\n  // No permitir la precarga de DNS\n  dnsPrefetchControl: { allow: false },\n\n  // Permitir que el sitio envíe el referente únicamente a sus propias páginas\n  referrerPolicy: { policy: 'same-origin' },\n\n  // Otras configuraciones de seguridad\n  contentSecurityPolicy: false // Deshabilitado para FCC testing\n}));\n\napp.use('/public', express.static(process.cwd() + '/public'));\n\n// CORS configurado para FCC testing - permite todos los orígenes\napp.use(cors({ origin: '*' }));\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// Middleware para agregar headers de no-cache para evitar problemas de cache\napp.use((req, res, next) => {\n  res.header('Cache-Control', 'no-cache, no-store, must-revalidate');\n  res.header('Pragma', 'no-cache');\n  res.header('Expires', '0');\n  next();\n});\n\n// Sample front-end routes\napp.route('/b/:board/')\n  .get(function (req, res) {\n    res.sendFile(process.cwd() + '/views/board.html');\n  });\n\napp.route('/b/:board/:threadid')\n  .get(function (req, res) {\n    res.sendFile(process.cwd() + '/views/thread.html');\n  });\n\n// Index page (static HTML)\napp.route('/')\n  .get(function (req, res) {\n    res.sendFile(process.cwd() + '/views/index.html');\n  });\n\n// For FCC testing purposes\nfccTestingRoutes(app);\n\n// Configuración de conexión a base de datos\nconst MONGO_URI = process.env.DB || process.env.MONGO_URI || 'mongodb://localhost:27017/anonymous_messageboard';\nconst PORT = process.env.PORT || 5000;\n\n// Función para crear una colección en memoria si no hay MongoDB disponible\nfunction createMemoryStorage() {\n  const threads = [];\n\n  const memoryDB = {\n    collection: function(name) {\n      return {\n        insertOne: async (doc) => {\n          if (!doc._id) {\n            const timestamp = Math.floor(new Date().getTime() / 1000).toString(16);\n            const randomHex = Math.random().toString(16).substr(2, 16);\n            const objectIdString = (timestamp + randomHex).padEnd(24, '0').substr(0, 24);\n            doc._id = { toString: () => objectIdString };\n          }\n          threads.push({ ...doc });\n          return { insertedId: doc._id };\n        },\n\n        find: (query = {}, options = {}) => ({\n          sort: (sortOptions) => ({\n            limit: (limitNum) => ({\n              toArray: async () => {\n                let filtered = threads.filter(t => {\n                  if (query.board && t.board !== query.board) return false;\n                  return true;\n                });\n\n                if (sortOptions && sortOptions.bumped_on === -1) {\n                  filtered.sort((a, b) => new Date(b.bumped_on) - new Date(a.bumped_on));\n                }\n\n                if (limitNum) {\n                  filtered = filtered.slice(0, limitNum);\n                }\n\n                if (options.projection) {\n                  filtered = filtered.map(item => {\n                    const projected = { ...item };\n                    Object.keys(options.projection).forEach(key => {\n                      if (options.projection[key] === 0) {\n                        delete projected[key];\n                      }\n                    });\n                    return projected;\n                  });\n                }\n\n                return filtered;\n              }\n            })\n          })\n        }),\n\n        findOne: async (query, options = {}) => {\n          let thread = threads.find(t => {\n            if (query._id && t._id.toString() !== query._id.toString()) return false;\n            if (query.board && t.board !== query.board) return false;\n            return true;\n          });\n\n          if (thread && options.projection) {\n            thread = { ...thread };\n            Object.keys(options.projection).forEach(key => {\n              if (options.projection[key] === 0) {\n                delete thread[key];\n              }\n            });\n          }\n\n          return thread;\n        },\n\n        updateOne: async (query, update) => {\n          const threadIndex = threads.findIndex(t => {\n            if (query._id && t._id.toString() !== query._id.toString()) return false;\n            if (query.board && t.board !== query.board) return false;\n            if (query['replies._id']) {\n              const replyExists = t.replies && t.replies.some(r => r._id.toString() === query['replies._id'].toString());\n              if (!replyExists) return false;\n            }\n            return true;\n          });\n\n          if (threadIndex === -1) return { matchedCount: 0 };\n\n          const thread = threads[threadIndex];\n\n          if (update.$set) {\n            if (update.$set['replies.$.reported']) {\n              const replyIndex = thread.replies.findIndex(r => r._id.toString() === query['replies._id'].toString());\n              if (replyIndex !== -1) {\n                thread.replies[replyIndex].reported = true;\n              }\n            } else if (update.$set['replies.$.text']) {\n              const replyIndex = thread.replies.findIndex(r => r._id.toString() === query['replies._id'].toString());\n              if (replyIndex !== -1) {\n                thread.replies[replyIndex].text = update.$set['replies.$.text'];\n              }\n            } else {\n              Object.assign(thread, update.$set);\n            }\n          }\n\n          if (update.$push) {\n            Object.keys(update.$push).forEach(key => {\n              if (!thread[key]) thread[key] = [];\n              thread[key].push(update.$push[key]);\n            });\n          }\n\n          return { matchedCount: 1 };\n        },\n\n        deleteOne: async (query) => {\n          const index = threads.findIndex(t => {\n            if (query._id && t._id.toString() !== query._id.toString()) return false;\n            if (query.board && t.board !== query.board) return false;\n            return true;\n          });\n\n          if (index > -1) {\n            threads.splice(index, 1);\n            return { deletedCount: 1 };\n          }\n          return { deletedCount: 0 };\n        }\n      };\n    }\n  };\n  return memoryDB;\n}\n\n// Intentar conectar a MongoDB, si falla usar almacenamiento en memoria\nasync function startServer() {\n  try {\n    console.log('Attempting to connect to MongoDB...');\n    const client = await MongoClient.connect(MONGO_URI, {\n      connectTimeoutMS: 5000,\n      serverSelectionTimeoutMS: 5000,\n      socketTimeoutMS: 5000\n    });\n    const db = client.db();\n    app.locals.db = db;\n    console.log('Connected to MongoDB successfully');\n\n    // ✅ Montar rutas API\n    apiRoutes(app);\n\n    startExpressServer();\n\n  } catch (err) {\n    console.log('MongoDB connection failed, using memory storage for development:', err.message);\n\n    // Usar almacenamiento en memoria\n    app.locals.db = createMemoryStorage();\n\n    // ✅ Montar rutas API también aquí\n    apiRoutes(app);\n\n    startExpressServer();\n  }\n}\n\nfunction startExpressServer() {\n  // 404 Not Found Middleware\n  app.use(function(req, res, next) {\n    res.status(404)\n      .type('text')\n      .send('Not Found');\n  });\n\n  // Start our server and tests!\n  const listener = app.listen(PORT, '0.0.0.0', function () {\n    console.log('Your app is listening on port ' + listener.address().port);\n\n    if (process.env.NODE_ENV === 'test') {\n      console.log('Running Tests...');\n      setTimeout(function () {\n        try {\n          runner.run();\n        } catch(e) {\n          console.log('Tests are not valid:');\n          console.error(e);\n        }\n      }, 1500);\n    }\n  });\n}\n\n// Iniciar el servidor\nstartServer();\n\nmodule.exports = app; // for testing\n","size_bytes":8148},"test-runner.js":{"content":"/*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*       DO NOT EDIT THIS FILE\n*       For FCC testing purposes!\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*/\n\nvar analyser = require('./assertion-analyser');\nvar EventEmitter = require('events').EventEmitter;\n\nvar Mocha = require('mocha'),\n    fs = require('fs'),\n    path = require('path');\n\nvar mocha = new Mocha();\nvar testDir = './tests'\n\n\n// Add each .js file to the mocha instance\nfs.readdirSync(testDir).filter(function(file){\n    // Only keep the .js files\n    return file.substr(-3) === '.js';\n\n}).forEach(function(file){\n    mocha.addFile(\n        path.join(testDir, file)\n    );\n});\n\nvar emitter = new EventEmitter();  \nemitter.run = function() {\n\n  var tests = [];\n  var context = \"\";\n  var separator = ' -> ';\n  // Run the tests.\n  try {\n  var runner = mocha.ui('tdd').run()\n    .on('test end', function(test) {\n        // remove comments\n        var body = test.body.replace(/\\/\\/.*\\n|\\/\\*.*\\*\\//g, '');\n        // collapse spaces\n        body = body.replace(/\\s+/g,' ');\n        var obj = {\n          title: test.title,\n          context: context.slice(0, -separator.length),\n          state: test.state,\n          // body: body,\n          assertions: analyser(body)\n        };\n        tests.push(obj);\n    })\n    .on('end', function() {\n        emitter.report = tests;\n        emitter.emit('done', tests)\n    })\n    .on('suite', function(s) {\n      context += (s.title + separator);\n\n    })\n    .on('suite end', function(s) {\n      context = context.slice(0, -(s.title.length + separator.length))\n    })\n  } catch(e) {\n    throw(e);\n  }\n};\n\nmodule.exports = emitter;\n\n/*\n * Mocha.runner Events:\n * can be used to build a better custom report\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n */","size_bytes":2140},"public/style.css":{"content":"* {\n  margin: 0px;\n  padding: 0px;\n}\n\nbody {\n  padding: 10px;\n}\n\n.replies {\n  margin-left: 50px;\n}\n\n.reply {\n  border: 1px dotted black;\n  margin: 5px;\n  padding: 5px;\n}\n\n.newReply {\n  margin: 10px 5px 10px 5px;\n}\n\n.thread {\n  border: 2px solid black;\n  padding: 5px;\n  margin-bottom: 5px;\n}\n\n.id {\n  font-size: 10.5px;\n}\n\n#submitNewThread {\n  margin: 50px;\n}","size_bytes":359},"routes/api.js":{"content":"'use strict';\n\nconst ThreadController = require('../controllers/threadController');\nconst ReplyController = require('../controllers/replyController');\nconst { ObjectId } = require('mongodb');\n\n// Función para validar ObjectId\nfunction isValidObjectId(id) {\n  if (!id || typeof id !== 'string') return false;\n  // Validar solo ObjectId de MongoDB (24 caracteres hexadecimales)\n  return /^[0-9a-fA-F]{24}$/.test(id);\n}\n\n// Función para crear ObjectId de forma segura\nfunction createObjectId(id) {\n  try {\n    return new ObjectId(id);\n  } catch (error) {\n    throw new Error('Invalid ID format');\n  }\n}\n\nmodule.exports = function (app) {\n  \n  // Middleware para obtener controladores con la conexión de base de datos\n  app.use((req, res, next) => {\n    if (app.locals.db) {\n      req.threadController = new ThreadController(app.locals.db);\n      req.replyController = new ReplyController(app.locals.db);\n    }\n    next();\n  });\n\n  // THREADS ROUTES\n  app.route('/api/threads/:board')\n    \n    // GET - Obtener los 10 hilos más recientes con 3 respuestas cada uno\n    .get(async (req, res) => {\n      try {\n        if (!req.threadController) {\n          return res.status(500).json({ error: 'Database not available' });\n        }\n        \n        const board = req.params.board;\n        const threads = await req.threadController.getRecentThreads(board);\n        res.json(threads);\n      } catch (error) {\n        console.error('Error getting threads:', error.message);\n        res.status(500).json({ error: 'Internal server error' });\n      }\n    })\n    \n    // POST - Crear un nuevo hilo\n    .post(async (req, res) => {\n      try {\n        if (!req.threadController) {\n          return res.status(500).json({ error: 'Database not available' });\n        }\n\n        const { text, delete_password } = req.body;\n        const board = req.params.board;\n\n        // Validación de entrada\n        if (!text || !delete_password) {\n          return res.status(400).json({ error: 'Missing required fields: text and delete_password' });\n        }\n\n        if (text.trim().length === 0) {\n          return res.status(400).json({ error: 'Text cannot be empty' });\n        }\n\n        const thread = await req.threadController.createThread(board, text.trim(), delete_password);\n        \n        // Redirigir según los requisitos de FreeCodeCamp\n        res.redirect(303, `/b/${board}/`);\n      } catch (error) {\n        console.error('Error creating thread:', error.message);\n        res.status(500).json({ error: 'Internal server error' });\n      }\n    })\n    \n    // PUT - Reportar un hilo\n    .put(async (req, res) => {\n      try {\n        if (!req.threadController) {\n          return res.status(500).json({ error: 'Database not available' });\n        }\n\n        const { thread_id } = req.body;\n        const board = req.params.board;\n\n        if (!thread_id) {\n          return res.status(400).json({ error: 'Missing thread_id' });\n        }\n\n        if (!isValidObjectId(thread_id)) {\n          return res.status(400).json({ error: 'Invalid thread_id format' });\n        }\n\n        const result = await req.threadController.reportThread(board, thread_id);\n        res.send(result);\n      } catch (error) {\n        console.error('Error reporting thread:', error.message);\n        if (error.message.includes('Thread not found')) {\n          return res.status(404).json({ error: 'Thread not found' });\n        }\n        res.status(500).json({ error: 'Internal server error' });\n      }\n    })\n    \n    // DELETE - Eliminar un hilo\n    .delete(async (req, res) => {\n      try {\n        if (!req.threadController) {\n          return res.status(500).json({ error: 'Database not available' });\n        }\n\n        const { thread_id, delete_password } = req.body;\n        const board = req.params.board;\n\n        if (!thread_id || !delete_password) {\n          return res.status(400).json({ error: 'Missing thread_id or delete_password' });\n        }\n\n        if (!isValidObjectId(thread_id)) {\n          return res.status(400).json({ error: 'Invalid thread_id format' });\n        }\n\n        const result = await req.threadController.deleteThread(board, thread_id, delete_password);\n        \n        // Manejar respuestas específicas de string\n        if (result === 'Thread not found') {\n          return res.status(404).send('Thread not found');\n        }\n        \n        res.send(result);\n      } catch (error) {\n        console.error('Error deleting thread:', error.message);\n        if (error.message.includes('Thread not found')) {\n          return res.status(404).send('Thread not found');\n        }\n        res.status(500).json({ error: 'Internal server error' });\n      }\n    });\n\n  // REPLIES ROUTES\n  app.route('/api/replies/:board')\n    \n    // GET - Obtener un hilo específico con todas sus respuestas\n    .get(async (req, res) => {\n      try {\n        if (!req.threadController) {\n          return res.status(500).json({ error: 'Database not available' });\n        }\n\n        const { thread_id } = req.query;\n        const board = req.params.board;\n\n        if (!thread_id) {\n          return res.status(400).json({ error: 'Missing thread_id query parameter' });\n        }\n\n        if (!isValidObjectId(thread_id)) {\n          return res.status(400).json({ error: 'Invalid thread_id format' });\n        }\n\n        const thread = await req.threadController.getThreadWithReplies(board, thread_id);\n        res.json(thread);\n      } catch (error) {\n        console.error('Error getting thread with replies:', error.message);\n        if (error.message.includes('Thread not found')) {\n          return res.status(404).json({ error: 'Thread not found' });\n        }\n        res.status(500).json({ error: 'Internal server error' });\n      }\n    })\n    \n    // POST - Crear una nueva respuesta\n    .post(async (req, res) => {\n      try {\n        if (!req.replyController) {\n          return res.status(500).json({ error: 'Database not available' });\n        }\n\n        const { thread_id, text, delete_password } = req.body;\n        const board = req.params.board;\n\n        // Validación de entrada\n        if (!thread_id || !text || !delete_password) {\n          return res.status(400).json({ error: 'Missing required fields: thread_id, text, and delete_password' });\n        }\n\n        if (!isValidObjectId(thread_id)) {\n          return res.status(400).json({ error: 'Invalid thread_id format' });\n        }\n\n        if (text.trim().length === 0) {\n          return res.status(400).json({ error: 'Text cannot be empty' });\n        }\n\n        const reply = await req.replyController.createReply(board, thread_id, text.trim(), delete_password);\n        \n        // Redirigir según los requisitos de FreeCodeCamp\n        res.redirect(303, `/b/${board}/${thread_id}`);\n      } catch (error) {\n        console.error('Error creating reply:', error.message);\n        if (error.message.includes('Thread not found')) {\n          return res.status(404).json({ error: 'Thread not found' });\n        }\n        res.status(500).json({ error: 'Internal server error' });\n      }\n    })\n    \n    // PUT - Reportar una respuesta\n    .put(async (req, res) => {\n      try {\n        if (!req.replyController) {\n          return res.status(500).json({ error: 'Database not available' });\n        }\n\n        const { thread_id, reply_id } = req.body;\n        const board = req.params.board;\n\n        if (!thread_id || !reply_id) {\n          return res.status(400).json({ error: 'Missing thread_id or reply_id' });\n        }\n\n        if (!isValidObjectId(thread_id) || !isValidObjectId(reply_id)) {\n          return res.status(400).json({ error: 'Invalid thread_id or reply_id format' });\n        }\n\n        const result = await req.replyController.reportReply(board, thread_id, reply_id);\n        res.send(result);\n      } catch (error) {\n        console.error('Error reporting reply:', error.message);\n        if (error.message.includes('Reply not found')) {\n          return res.status(404).json({ error: 'Reply not found' });\n        }\n        res.status(500).json({ error: 'Internal server error' });\n      }\n    })\n    \n    // DELETE - Eliminar una respuesta\n    .delete(async (req, res) => {\n      try {\n        if (!req.replyController) {\n          return res.status(500).json({ error: 'Database not available' });\n        }\n\n        const { thread_id, reply_id, delete_password } = req.body;\n        const board = req.params.board;\n\n        if (!thread_id || !reply_id || !delete_password) {\n          return res.status(400).json({ error: 'Missing thread_id, reply_id, or delete_password' });\n        }\n\n        if (!isValidObjectId(thread_id) || !isValidObjectId(reply_id)) {\n          return res.status(400).json({ error: 'Invalid thread_id or reply_id format' });\n        }\n\n        const result = await req.replyController.deleteReply(board, thread_id, reply_id, delete_password);\n        \n        // Manejar respuestas específicas de string\n        if (result === 'Reply not found' || result === 'Thread not found') {\n          return res.status(404).send(result);\n        }\n        \n        res.send(result);\n      } catch (error) {\n        console.error('Error deleting reply:', error.message);\n        if (error.message.includes('Reply not found') || error.message.includes('Thread not found')) {\n          return res.status(404).send(error.message.includes('Thread') ? 'Thread not found' : 'Reply not found');\n        }\n        res.status(500).json({ error: 'Internal server error' });\n      }\n    });\n\n};","size_bytes":9499},"routes/fcctesting.js":{"content":"/*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*       DO NOT EDIT THIS FILE\n*       For FCC testing purposes!\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*/\n\n'use strict';\n\nvar cors = require('cors');\nvar fs = require('fs');\nvar runner = require('../test-runner');\n\nmodule.exports = function (app) {\n\n  app.route('/_api/server.js')\n    .get(function(req, res, next) {\n      console.log('requested');\n      fs.readFile(__dirname + '/server.js', function(err, data) {\n        if(err) return next(err);\n        res.send(data.toString());\n      });\n    });\n  app.route('/_api/routes/api.js')\n    .get(function(req, res, next) {\n      console.log('requested');\n      fs.readFile(__dirname + '/routes/api.js', function(err, data) {\n        if(err) return next(err);\n        res.type('txt').send(data.toString());\n      });\n    });\n  app.route('/_api/controllers/convertHandler.js')\n    .get(function(req, res, next) {\n      console.log('requested');\n      fs.readFile(__dirname + '/controllers/convertHandler.js', function(err, data) {\n        if(err) return next(err);\n        res.type('txt').send(data.toString());\n      });\n    });\n\n  app.get('/_api/get-tests', cors(), function(req, res, next){\n    console.log('requested');\n    if(process.env.NODE_ENV === 'test') return next();\n    res.json({status: 'unavailable'});\n  },\n  function(req, res, next){\n    if(!runner.report) return next();\n    res.json(testFilter(runner.report, req.query.type, req.query.n));\n  },\n  function(req, res){\n    runner.on('done', function(report){\n      process.nextTick(() =>  res.json(testFilter(runner.report, req.query.type, req.query.n)));\n    });\n  });\n  app.get('/_api/app-info', function(req, res) {\n    res.json({ headers: res.getHeaders()});\n  });\n  \n};\n\nfunction testFilter(tests, type, n) {\n  var out;\n  switch (type) {\n    case 'unit' :\n      out = tests.filter(t => t.context.match('Unit Tests'));\n      break;\n    case 'functional':\n      out = tests.filter(t => t.context.match('Functional Tests') && !t.title.match('#example'));\n      break;\n    default:\n      out = tests;\n  }\n  if(n !== undefined) {\n    return out[n] || out;\n  }\n  return out;\n}","size_bytes":2098},"tests/2_functional-tests.js":{"content":"const chaiHttp = require('chai-http');\nconst chai = require('chai');\nconst assert = chai.assert;\nconst server = require('../server');\n\nchai.use(chaiHttp);\n\nlet testThreadId;\nlet testReplyId;\n\nsuite('Functional Tests', function() {\n\n  suite('API ROUTING FOR /api/threads/:board', function() {\n    \n    test('Creating a new thread: POST request to /api/threads/{board}', function(done) {\n      chai.request(server)\n        .post('/api/threads/test')\n        .send({\n          text: 'Test thread text',\n          delete_password: 'password123'\n        })\n        .redirects(0) // No seguir redirecciones automáticamente\n        .end(function(err, res) {\n          // Verificar redirección 303\n          assert.equal(res.status, 303);\n          assert.equal(res.headers.location, '/b/test/');\n          \n          // Ahora obtener los hilos para verificar que se creó correctamente\n          chai.request(server)\n            .get('/api/threads/test')\n            .end(function(err, res2) {\n              assert.equal(res2.status, 200);\n              assert.isArray(res2.body);\n              assert.isAtLeast(res2.body.length, 1);\n              \n              // Encontrar nuestro hilo\n              const createdThread = res2.body.find(t => t.text === 'Test thread text');\n              assert.exists(createdThread);\n              assert.property(createdThread, '_id');\n              assert.property(createdThread, 'text');\n              assert.equal(createdThread.text, 'Test thread text');\n              assert.property(createdThread, 'created_on');\n              assert.property(createdThread, 'bumped_on');\n              assert.property(createdThread, 'replies');\n              assert.isArray(createdThread.replies);\n              assert.notProperty(createdThread, 'delete_password');\n              assert.notProperty(createdThread, 'reported');\n              \n              // Guardar el ID del hilo para pruebas posteriores\n              testThreadId = createdThread._id;\n              done();\n            });\n        });\n    });\n    \n    test('Viewing the 10 most recent threads with 3 replies each: GET request to /api/threads/{board}', function(done) {\n      chai.request(server)\n        .get('/api/threads/test')\n        .end(function(err, res) {\n          assert.equal(res.status, 200);\n          assert.isArray(res.body);\n          assert.isAtMost(res.body.length, 10);\n          \n          if (res.body.length > 0) {\n            assert.property(res.body[0], '_id');\n            assert.property(res.body[0], 'text');\n            assert.property(res.body[0], 'created_on');\n            assert.property(res.body[0], 'bumped_on');\n            assert.property(res.body[0], 'replies');\n            assert.isArray(res.body[0].replies);\n            assert.isAtMost(res.body[0].replies.length, 3);\n            \n            // Verificar que campos sensibles no estén presentes\n            assert.notProperty(res.body[0], 'delete_password');\n            assert.notProperty(res.body[0], 'reported');\n            \n            // Verificar que las respuestas no tengan campos sensibles\n            if (res.body[0].replies.length > 0) {\n              assert.notProperty(res.body[0].replies[0], 'delete_password');\n              assert.notProperty(res.body[0].replies[0], 'reported');\n            }\n          }\n          done();\n        });\n    });\n    \n    test('Deleting a thread with the incorrect password: DELETE request to /api/threads/{board} with invalid delete_password', function(done) {\n      chai.request(server)\n        .delete('/api/threads/test')\n        .send({\n          thread_id: testThreadId,\n          delete_password: 'wrongpassword'\n        })\n        .end(function(err, res) {\n          assert.equal(res.status, 200);\n          assert.equal(res.text, 'incorrect password');\n          done();\n        });\n    });\n    \n    test('Deleting a thread with the correct password: DELETE request to /api/threads/{board} with valid delete_password', function(done) {\n      // Primero crear un nuevo hilo para eliminar\n      chai.request(server)\n        .post('/api/threads/test')\n        .send({\n          text: 'Thread to delete',\n          delete_password: 'deletepass'\n        })\n        .end(function(err, res) {\n          const threadIdToDelete = res.body._id;\n          \n          // Ahora eliminar el hilo con la contraseña correcta\n          chai.request(server)\n            .delete('/api/threads/test')\n            .send({\n              thread_id: threadIdToDelete,\n              delete_password: 'deletepass'\n            })\n            .end(function(err, res) {\n              assert.equal(res.status, 200);\n              assert.equal(res.text, 'success');\n              done();\n            });\n        });\n    });\n    \n    test('Reporting a thread: PUT request to /api/threads/{board}', function(done) {\n      chai.request(server)\n        .put('/api/threads/test')\n        .send({\n          thread_id: testThreadId\n        })\n        .end(function(err, res) {\n          assert.equal(res.status, 200);\n          assert.equal(res.text, 'reported');\n          done();\n        });\n    });\n\n  });\n  \n  suite('API ROUTING FOR /api/replies/:board', function() {\n    \n    test('Creating a new reply: POST request to /api/replies/{board}', function(done) {\n      chai.request(server)\n        .post('/api/replies/test')\n        .send({\n          thread_id: testThreadId,\n          text: 'Test reply text',\n          delete_password: 'replypass'\n        })\n        .redirects(0) // No seguir redirecciones automáticamente\n        .end(function(err, res) {\n          // Verificar redirección 303\n          assert.equal(res.status, 303);\n          assert.equal(res.headers.location, `/b/test/${testThreadId}`);\n          \n          // Ahora obtener el hilo para verificar que la respuesta se creó correctamente\n          chai.request(server)\n            .get('/api/replies/test')\n            .query({ thread_id: testThreadId })\n            .end(function(err, res2) {\n              assert.equal(res2.status, 200);\n              assert.property(res2.body, 'replies');\n              assert.isArray(res2.body.replies);\n              assert.isAtLeast(res2.body.replies.length, 1);\n              \n              // Encontrar nuestra respuesta\n              const createdReply = res2.body.replies.find(r => r.text === 'Test reply text');\n              assert.exists(createdReply);\n              assert.property(createdReply, '_id');\n              assert.property(createdReply, 'text');\n              assert.equal(createdReply.text, 'Test reply text');\n              assert.property(createdReply, 'created_on');\n              assert.notProperty(createdReply, 'delete_password');\n              assert.notProperty(createdReply, 'reported');\n              \n              // Guardar el ID de la respuesta para pruebas posteriores\n              testReplyId = createdReply._id;\n              done();\n            });\n        });\n    });\n    \n    test('Viewing a single thread with all replies: GET request to /api/replies/{board}', function(done) {\n      chai.request(server)\n        .get('/api/replies/test')\n        .query({ thread_id: testThreadId })\n        .end(function(err, res) {\n          assert.equal(res.status, 200);\n          assert.property(res.body, '_id');\n          assert.property(res.body, 'text');\n          assert.property(res.body, 'created_on');\n          assert.property(res.body, 'bumped_on');\n          assert.property(res.body, 'replies');\n          assert.isArray(res.body.replies);\n          \n          // Verificar que campos sensibles no estén presentes\n          assert.notProperty(res.body, 'delete_password');\n          assert.notProperty(res.body, 'reported');\n          \n          // Verificar que las respuestas no tengan campos sensibles\n          if (res.body.replies.length > 0) {\n            assert.notProperty(res.body.replies[0], 'delete_password');\n            assert.notProperty(res.body.replies[0], 'reported');\n            assert.property(res.body.replies[0], '_id');\n            assert.property(res.body.replies[0], 'text');\n            assert.property(res.body.replies[0], 'created_on');\n          }\n          done();\n        });\n    });\n    \n    test('Deleting a reply with the incorrect password: DELETE request to /api/replies/{board} with invalid delete_password', function(done) {\n      chai.request(server)\n        .delete('/api/replies/test')\n        .send({\n          thread_id: testThreadId,\n          reply_id: testReplyId,\n          delete_password: 'wrongpassword'\n        })\n        .end(function(err, res) {\n          assert.equal(res.status, 200);\n          assert.equal(res.text, 'incorrect password');\n          done();\n        });\n    });\n    \n    test('Deleting a reply with the correct password: DELETE request to /api/replies/{board} with valid delete_password', function(done) {\n      chai.request(server)\n        .delete('/api/replies/test')\n        .send({\n          thread_id: testThreadId,\n          reply_id: testReplyId,\n          delete_password: 'replypass'\n        })\n        .end(function(err, res) {\n          assert.equal(res.status, 200);\n          assert.equal(res.text, 'success');\n          done();\n        });\n    });\n    \n    test('Reporting a reply: PUT request to /api/replies/{board}', function(done) {\n      // Primero crear una nueva respuesta para reportar\n      chai.request(server)\n        .post('/api/replies/test')\n        .send({\n          thread_id: testThreadId,\n          text: 'Reply to report',\n          delete_password: 'testpass'\n        })\n        .end(function(err, res) {\n          const replyIdToReport = res.body._id;\n          \n          // Ahora reportar la respuesta\n          chai.request(server)\n            .put('/api/replies/test')\n            .send({\n              thread_id: testThreadId,\n              reply_id: replyIdToReport\n            })\n            .end(function(err, res) {\n              assert.equal(res.status, 200);\n              assert.equal(res.text, 'reported');\n              done();\n            });\n        });\n    });\n\n  });\n\n});","size_bytes":10065},"replit.md":{"content":"# Anonymous Message Board\n\n## Overview\n\nThis is an Anonymous Message Board project built for FreeCodeCamp's Information Security certification. The application allows users to create message boards where they can post threads and replies anonymously. It implements security features using Helmet.js and provides a REST API for managing threads and replies with MongoDB as the data storage solution.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Backend Architecture\n- **Framework**: Express.js server with RESTful API design\n- **Language**: Node.js with JavaScript\n- **Architecture Pattern**: MVC (Model-View-Controller) with separate controllers for threads and replies\n- **Security**: Helmet.js middleware for security headers including frame protection, DNS prefetch control, and referrer policy\n- **Request Handling**: Body-parser for JSON and URL-encoded data, CORS enabled for cross-origin requests\n\n### Frontend Architecture\n- **Static Files**: HTML views served from `/views` directory with CSS styling\n- **Client-Side**: jQuery for dynamic content loading and form submissions\n- **Routing**: Server-side routing for board pages (`/b/:board/`) and thread pages\n- **UI Components**: Separate HTML files for index, board view, and individual thread view\n\n### Data Storage\n- **Database**: MongoDB for persistent data storage\n- **Collections**: Single `threads` collection storing both threads and their nested replies\n- **Data Models**: \n  - Threads contain text, timestamps, delete passwords, and embedded replies array\n  - Replies are embedded documents within threads with their own IDs and metadata\n\n### API Structure\n- **Thread Endpoints**: \n  - `GET/POST /api/threads/:board` - List recent threads or create new thread\n  - `PUT/DELETE /api/threads/:board` - Report or delete specific threads\n- **Reply Endpoints**:\n  - `GET/POST /api/replies/:board` - Get thread with all replies or add new reply\n  - `PUT/DELETE /api/replies/:board` - Report or delete specific replies\n- **Response Format**: JSON with filtered fields (passwords and reported status hidden from GET requests)\n\n### Security Features\n- **Password Protection**: Delete passwords required for thread/reply deletion (hashed storage recommended)\n- **Reporting System**: Users can report inappropriate content without authentication\n- **Input Validation**: ObjectId validation for MongoDB document references\n- **Headers Security**: Helmet.js configured for frame protection and secure headers\n- **Data Filtering**: Sensitive fields (passwords, reported status) excluded from public API responses\n\n## External Dependencies\n\n- **Database**: MongoDB (version 6.20.0) for data persistence\n- **Web Framework**: Express.js for HTTP server and routing\n- **Security**: Helmet.js for security headers and protection\n- **Environment**: dotenv for environment variable management\n- **Testing**: Mocha and Chai for functional testing suite\n- **Utilities**: CORS for cross-origin requests, body-parser for request parsing","size_bytes":3043},"controllers/replyController.js":{"content":"'use strict';\n\nconst { ObjectId } = require('mongodb');\n\nclass ReplyController {\n  constructor(db) {\n    this.db = db;\n    this.collection = db.collection('threads');\n  }\n\n  // Crear una nueva respuesta\n  async createReply(board, threadId, text, deletePassword) {\n    try {\n      const newReply = {\n        _id: new ObjectId(),\n        text: text,\n        created_on: new Date(),\n        delete_password: deletePassword,\n        reported: false\n      };\n\n      const result = await this.collection.updateOne(\n        { _id: new ObjectId(threadId), board: board },\n        {\n          $push: { replies: newReply },\n          $set: { bumped_on: new Date() }\n        }\n      );\n\n      if (result.matchedCount === 0) {\n        throw new Error('Thread not found');\n      }\n\n      return {\n        _id: newReply._id.toString(),\n        text: newReply.text,\n        created_on: newReply.created_on\n      };\n    } catch (error) {\n      throw new Error('Error creating reply: ' + error.message);\n    }\n  }\n\n  // Reportar una respuesta\n  async reportReply(board, threadId, replyId) {\n    try {\n      const result = await this.collection.updateOne(\n        { \n          _id: new ObjectId(threadId), \n          board: board,\n          'replies._id': new ObjectId(replyId)\n        },\n        { \n          $set: { 'replies.$.reported': true } \n        }\n      );\n\n      if (result.matchedCount === 0) {\n        throw new Error('Reply not found');\n      }\n\n      return 'reported';\n    } catch (error) {\n      throw new Error('Error reporting reply: ' + error.message);\n    }\n  }\n\n  // Eliminar una respuesta\n  async deleteReply(board, threadId, replyId, deletePassword) {\n    try {\n      // Primero encontrar el hilo y la respuesta\n      const thread = await this.collection.findOne({\n        _id: new ObjectId(threadId),\n        board: board\n      });\n\n      if (!thread) {\n        throw new Error('Thread not found');\n      }\n\n      const reply = thread.replies.find(r => r._id.toString() === replyId);\n      if (!reply) {\n        throw new Error('Reply not found');\n      }\n\n      if (reply.delete_password !== deletePassword) {\n        return 'incorrect password';\n      }\n\n      // En lugar de eliminar la respuesta, cambiar el texto a \"[deleted]\"\n      const result = await this.collection.updateOne(\n        { \n          _id: new ObjectId(threadId), \n          board: board,\n          'replies._id': new ObjectId(replyId)\n        },\n        { \n          $set: { 'replies.$.text': '[deleted]' } \n        }\n      );\n\n      if (result.matchedCount === 1) {\n        return 'success';\n      } else {\n        throw new Error('Reply not found');\n      }\n    } catch (error) {\n      if (error.message.includes('incorrect password')) {\n        return 'incorrect password';\n      }\n      throw error; // Propagar el error para que routes lo maneje apropiadamente\n    }\n  }\n}\n\nmodule.exports = ReplyController;","size_bytes":2892},"controllers/threadController.js":{"content":"'use strict';\n\nconst { ObjectId } = require('mongodb');\n\nclass ThreadController {\n  constructor(db) {\n    this.db = db;\n    this.collection = db.collection('threads');\n  }\n\n  // Crear un nuevo hilo\n  async createThread(board, text, deletePassword) {\n    try {\n      const newThread = {\n        _id: new ObjectId(),\n        text: text,\n        created_on: new Date(),\n        bumped_on: new Date(),\n        reported: false,\n        delete_password: deletePassword,\n        replies: [],\n        board: board\n      };\n\n      const result = await this.collection.insertOne(newThread);\n      return { \n        _id: result.insertedId.toString(),\n        text: newThread.text,\n        created_on: newThread.created_on,\n        bumped_on: newThread.bumped_on,\n        replies: []\n      };\n    } catch (error) {\n      throw new Error('Error creating thread: ' + error.message);\n    }\n  }\n\n  // Obtener los 10 hilos más recientes con sus 3 respuestas más recientes\n  async getRecentThreads(board) {\n    try {\n      const threads = await this.collection\n        .find({ board: board }, {\n          projection: {\n            delete_password: 0,\n            reported: 0,\n            board: 0\n          }\n        })\n        .sort({ bumped_on: -1 })\n        .limit(10)\n        .toArray();\n\n      // Limitar replies a las 3 más recientes y ocultar campos sensibles\n      const sanitizedThreads = threads.map(thread => ({\n        _id: thread._id.toString(),\n        text: thread.text,\n        created_on: thread.created_on,\n        bumped_on: thread.bumped_on,\n        replies: thread.replies\n          .sort((a, b) => b.created_on - a.created_on)\n          .slice(0, 3)\n          .map(reply => ({\n            _id: reply._id.toString(),\n            text: reply.text,\n            created_on: reply.created_on\n          }))\n      }));\n\n      return sanitizedThreads;\n    } catch (error) {\n      throw new Error('Error getting threads: ' + error.message);\n    }\n  }\n\n  // Reportar un hilo\n  async reportThread(board, threadId) {\n    try {\n      const result = await this.collection.updateOne(\n        { _id: new ObjectId(threadId), board: board },\n        { $set: { reported: true } }\n      );\n\n      if (result.matchedCount === 0) {\n        throw new Error('Thread not found');\n      }\n\n      return 'reported';\n    } catch (error) {\n      throw new Error('Error reporting thread: ' + error.message);\n    }\n  }\n\n  // Eliminar un hilo\n  async deleteThread(board, threadId, deletePassword) {\n    try {\n      const thread = await this.collection.findOne({\n        _id: new ObjectId(threadId),\n        board: board\n      });\n\n      if (!thread) {\n        throw new Error('Thread not found');\n      }\n\n      if (thread.delete_password !== deletePassword) {\n        return 'incorrect password';\n      }\n\n      const result = await this.collection.deleteOne({\n        _id: new ObjectId(threadId),\n        board: board\n      });\n\n      if (result.deletedCount === 1) {\n        return 'success';\n      } else {\n        throw new Error('Thread not found');\n      }\n    } catch (error) {\n      if (error.message.includes('incorrect password')) {\n        return 'incorrect password';\n      }\n      throw error; // Propagar el error para que routes lo maneje apropiadamente\n    }\n  }\n\n  // Obtener un hilo específico con todas sus respuestas\n  async getThreadWithReplies(board, threadId) {\n    try {\n      const thread = await this.collection.findOne(\n        { _id: new ObjectId(threadId), board: board },\n        {\n          projection: {\n            delete_password: 0,\n            reported: 0,\n            board: 0\n          }\n        }\n      );\n\n      if (!thread) {\n        throw new Error('Thread not found');\n      }\n\n      // Ocultar campos sensibles de las respuestas\n      const sanitizedReplies = thread.replies.map(reply => ({\n        _id: reply._id.toString(),\n        text: reply.text,\n        created_on: reply.created_on\n      }));\n\n      return {\n        _id: thread._id.toString(),\n        text: thread.text,\n        created_on: thread.created_on,\n        bumped_on: thread.bumped_on,\n        replies: sanitizedReplies\n      };\n    } catch (error) {\n      throw new Error('Error getting thread: ' + error.message);\n    }\n  }\n}\n\nmodule.exports = ThreadController;","size_bytes":4253}},"version":1}